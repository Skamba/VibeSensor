name: Main Release

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: main-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          base_ver="$(date -u +%Y.%-m.%-d)"
          existing="$(git tag -l "server-v${base_ver}*" | sort -V | tail -n1 || true)"
          if [ -z "${existing}" ]; then
            version="${base_ver}"
          else
            suffix="${existing##server-v${base_ver}}"
            if [ -z "${suffix}" ]; then
              version="${base_ver}.1"
            else
              n="${suffix#.}"
              version="${base_ver}.$((n + 1))"
            fi
          fi
          echo "version=${version}" >> "${GITHUB_OUTPUT}"
          echo "tag=server-v${version}" >> "${GITHUB_OUTPUT}"
          echo "bundle=vibesensor-fw-v${version}.zip" >> "${GITHUB_OUTPUT}"

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: npm
          cache-dependency-path: apps/ui/package-lock.json

      - name: Build UI
        shell: bash
        run: |
          set -euo pipefail
          node tools/config/sync_shared_contracts_to_ui.mjs
          cd apps/ui
          npm ci
          npm run typecheck
          npm run build

      - name: Copy UI dist into package static dir
        shell: bash
        run: |
          set -euo pipefail
          rm -rf apps/server/vibesensor/static
          cp -r apps/ui/dist apps/server/vibesensor/static

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip
          cache-dependency-path: apps/server/pyproject.toml

      - name: Stamp version and build server wheel
        shell: bash
        run: |
          set -euo pipefail
          version="${{ steps.version.outputs.version }}"
          cat > apps/server/vibesensor/_version.py <<PYEOF
          # Auto-generated by CI - do not edit.
          __version__ = "${version}"
          PYEOF
          sed -i 's/^          //' apps/server/vibesensor/_version.py
          python -m pip install --upgrade pip build
          python -m build --wheel apps/server/

      - name: Install PlatformIO
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install pipx
          python -m pipx ensurepath
          echo "${HOME}/.local/bin" >> "${GITHUB_PATH}"
          pipx install platformio

      - name: Detect firmware directory
        id: firmware_dir
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t platformio_files < <(git ls-files 'platformio.ini' ':(glob)**/platformio.ini' | sort)
          if [ "${#platformio_files[@]}" -eq 0 ]; then
            echo "No platformio.ini found in repository." >&2
            exit 1
          fi

          selected_file="${platformio_files[0]}"
          for candidate in "${platformio_files[@]}"; do
            if [[ "${candidate}" == firmware/* ]]; then
              selected_file="${candidate}"
              break
            fi
          done

          firmware_dir="$(dirname "${selected_file}")"
          echo "Using firmware directory: ${firmware_dir}"
          echo "path=${firmware_dir}" >> "${GITHUB_OUTPUT}"

      - name: Build firmware
        shell: bash
        run: |
          set -euo pipefail
          cd "${{ steps.firmware_dir.outputs.path }}"
          pio run

      - name: Package firmware artifacts
        shell: bash
        run: |
          set -euo pipefail
          cd "${{ steps.firmware_dir.outputs.path }}"
          mkdir -p dist

          mapfile -t firmware_bins < <(find .pio/build -mindepth 2 -maxdepth 2 -type f -name firmware.bin | sort)
          if [ "${#firmware_bins[@]}" -eq 0 ]; then
            echo "No firmware.bin found under .pio/build." >&2
            exit 1
          fi

          for firmware_bin in "${firmware_bins[@]}"; do
            env_dir="$(dirname "${firmware_bin}")"
            env_name="$(basename "${env_dir}")"
            target_dir="dist/${env_name}"
            mkdir -p "${target_dir}"

            cp "${env_dir}/firmware.bin" "${target_dir}/firmware.bin"
            if [ -f "${env_dir}/bootloader.bin" ]; then
              cp "${env_dir}/bootloader.bin" "${target_dir}/bootloader.bin"
            fi
            if [ -f "${env_dir}/partitions.bin" ]; then
              cp "${env_dir}/partitions.bin" "${target_dir}/partitions.bin"
            fi
            if [ -f "${env_dir}/boot_app0.bin" ]; then
              cp "${env_dir}/boot_app0.bin" "${target_dir}/boot_app0.bin"
            fi
          done

      - name: Generate flash manifest
        shell: bash
        run: |
          set -euo pipefail
          cd "${{ steps.firmware_dir.outputs.path }}"

          python - <<'PY'
          import hashlib
          import json
          import os
          import re
          import subprocess
          from pathlib import Path

          dist = Path("dist")
          standard_esp32_app_offset = "0x10000"
          manifest = {"generated_from": os.getenv("GITHUB_SHA", "unknown"), "environments": []}
          env_dirs = sorted([p for p in dist.iterdir() if p.is_dir()])
          for env_dir in env_dirs:
              env_name = env_dir.name
              app_offset = standard_esp32_app_offset
              try:
                  envdump = subprocess.run(
                      ["pio", "run", "-e", env_name, "-t", "envdump"],
                      check=True,
                      capture_output=True,
                      text=True,
                  ).stdout
                  match = re.search(r"ESP32_APP_OFFSET[^0-9A-Fa-f]*(0x[0-9A-Fa-f]+)", envdump)
                  if match:
                      parsed_offset = match.group(1)
                      app_offset = hex(int(parsed_offset, 16))
              except (subprocess.CalledProcessError, ValueError):
                  pass

              segments = []
              for file_name, offset in (
                  ("firmware.bin", app_offset),
                  ("bootloader.bin", "0x1000"),
                  ("partitions.bin", "0x8000"),
                  ("boot_app0.bin", "0xe000"),
              ):
                  artifact = env_dir / file_name
                  if artifact.exists():
                      segments.append(
                          {
                              "file": f"{env_name}/{file_name}",
                              "offset": offset,
                              "sha256": hashlib.sha256(artifact.read_bytes()).hexdigest(),
                          }
                      )

              manifest["environments"].append({"name": env_name, "segments": segments})

          (dist / "flash.json").write_text(json.dumps(manifest, indent=2) + "\n", encoding="utf-8")
          PY

      - name: Create firmware bundle
        id: bundle
        shell: bash
        run: |
          set -euo pipefail
          cd "${{ steps.firmware_dir.outputs.path }}"
          bundle_name="${{ steps.version.outputs.bundle }}"
          rm -f "${bundle_name}"
          (cd dist && zip -r "../${bundle_name}" .)
          echo "path=${{ steps.firmware_dir.outputs.path }}/${bundle_name}" >> "${GITHUB_OUTPUT}"

      - name: Generate changelog
        id: changelog
        shell: bash
        run: |
          set -euo pipefail
          latest_tag="$(git tag -l 'server-v*' --sort=-creatordate | head -n1 || true)"
          if [ -z "${latest_tag}" ]; then
            range="HEAD"
          else
            range="${latest_tag}..HEAD"
          fi
          {
            echo "body<<CHANGELOG_EOF"
            echo "## Changes"
            echo ""
            git log --oneline --no-decorate --max-count=50 "${range}"
            echo ""
            echo "CHANGELOG_EOF"
          } >> "${GITHUB_OUTPUT}"

      - name: Create combined release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.version }}
          body: ${{ steps.changelog.outputs.body }}
          prerelease: false
          files: |
            apps/server/dist/*.whl
            ${{ steps.bundle.outputs.path }}

      - name: Remove superseded releases
        uses: actions/github-script@v7
        env:
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
        with:
          script: |
            const currentTag = process.env.CURRENT_TAG;
            const tagPatterns = [/^server-v/, /^fw-v/];
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });

            for (const release of releases) {
              const tag = release.tag_name || "";
              if (tag === currentTag) {
                continue;
              }
              if (!tagPatterns.some((pattern) => pattern.test(tag))) {
                continue;
              }

              core.info(`Deleting superseded release ${tag}`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
              });

              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tag}`,
                });
              } catch (error) {
                if (error.status !== 404) {
                  throw error;
                }
                core.warning(`Tag ${tag} was already absent`);
              }
            }
