#!/usr/bin/env python3
from __future__ import annotations

import argparse
import datetime as dt
import fnmatch
import re
import subprocess
from pathlib import Path


ROOT = Path(__file__).resolve().parents[2]
LOG_DIR = ROOT / "artifacts" / "ai" / "logs"


def _stamp() -> str:
    return dt.datetime.now().strftime("%Y%m%d-%H%M%S")


def _collect_files(target: str, limit: int = 80) -> list[Path]:
    results: list[Path] = []
    if any(ch in target for ch in "*?[]"):
        for p in ROOT.rglob("*"):
            if p.is_file() and fnmatch.fnmatch(str(p.relative_to(ROOT)), target):
                results.append(p)
    else:
        base = (ROOT / target).resolve()
        if base.is_file():
            results = [base]
        elif base.is_dir():
            for ext in ("*.py", "*.ts", "*.tsx", "*.js", "*.sh", "*.md", "*.yml", "*.yaml"):
                results.extend(base.rglob(ext))
    return sorted(results)[:limit]


def _public_symbols(path: Path, max_symbols: int = 8) -> list[str]:
    try:
        lines = path.read_text(encoding="utf-8", errors="replace").splitlines()
    except OSError:
        return []
    symbols: list[str] = []
    for i, line in enumerate(lines, start=1):
        m = re.match(r"\s*(def|class)\s+([A-Za-z_][A-Za-z0-9_]*)", line)
        if not m:
            continue
        name = m.group(2)
        if name.startswith("_"):
            continue
        symbols.append(f"{path.relative_to(ROOT)}:{i} {m.group(1)} {name}")
        if len(symbols) >= max_symbols:
            break
    return symbols


def _rg_symbol(symbol: str, scope: str, max_lines: int = 20) -> list[str]:
    cmd = ["rg", "-n", "--no-heading", "--max-count", str(max_lines), symbol, scope]
    try:
        out = subprocess.run(cmd, cwd=str(ROOT), capture_output=True, text=True, check=False)
    except FileNotFoundError:
        return []
    if out.returncode not in (0, 1):
        return []
    return [line for line in out.stdout.splitlines() if line.strip()][:max_lines]


def main() -> int:
    parser = argparse.ArgumentParser(description="Scoped low-noise repository triage")
    parser.add_argument("target", help="folder/file or glob (workspace-relative)")
    parser.add_argument("--symbol", help="optional symbol to find call sites", default="")
    args = parser.parse_args()

    LOG_DIR.mkdir(parents=True, exist_ok=True)
    detail_file = LOG_DIR / f"{_stamp()}-triage-details.txt"

    files = _collect_files(args.target)
    test_files = [p for p in files if "tests" in p.parts]
    modules = [p for p in files if p.suffix in {".py", ".ts", ".tsx", ".js", ".sh"}]

    symbols: list[str] = []
    for fp in modules[:15]:
        symbols.extend(_public_symbols(fp, max_symbols=3))
        if len(symbols) >= 24:
            break
    symbols = symbols[:24]

    call_sites = _rg_symbol(args.symbol, args.target) if args.symbol else []

    with detail_file.open("w", encoding="utf-8") as fh:
        fh.write(f"target={args.target}\n")
        fh.write(f"files={len(files)}\n")
        fh.write("\n[modules]\n")
        for fp in modules[:40]:
            fh.write(f"- {fp.relative_to(ROOT)}\n")
        fh.write("\n[tests]\n")
        for fp in test_files[:30]:
            fh.write(f"- {fp.relative_to(ROOT)}\n")
        fh.write("\n[public-symbols]\n")
        for line in symbols:
            fh.write(f"- {line}\n")
        if args.symbol:
            fh.write(f"\n[call-sites:{args.symbol}]\n")
            for line in call_sites:
                fh.write(f"- {line}\n")

    print(f"Triage target: {args.target}")
    print(f"- files scanned: {len(files)}")
    print(f"- modules found: {len(modules)}")
    print(f"- tests found: {len(test_files)}")
    print(f"- public symbols sampled: {len(symbols)}")
    if args.symbol:
        print(f"- call sites sampled for '{args.symbol}': {len(call_sites)}")
    print(f"- details: {detail_file.relative_to(ROOT)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
